//
//  The MIT License (MIT)
//
//  Copyright (c) 2015 Srdan Rasic (@srdanrasic)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

/// Abstraction over an event type generated by a ObservableArray.
/// ObservableArray event encapsulates current state of the array, as well
/// as the operation that has triggered an event.
public protocol ObservableArrayEventType {
  typealias ObservableArrayEventSequenceType: SequenceType
  var sequence: ObservableArrayEventSequenceType { get }
  var operation: ObservableArrayOperation<ObservableArrayEventSequenceType.Generator.Element> { get }
}

/// A concrete array event type.
public struct ObservableArrayEvent<ObservableArrayEventSequenceType: SequenceType>: ObservableArrayEventType {
  public let sequence: ObservableArrayEventSequenceType
  public let operation: ObservableArrayOperation<ObservableArrayEventSequenceType.Generator.Element>
}

/// Represents an operation that can be applied to a ObservableArray.
/// Note: Nesting of the .Batch operations is not supported at the moment.
public indirect enum ObservableArrayOperation<ElementType> {
  case Insert(elements: [ElementType], fromIndex: Int)
  case Update(elements: [ElementType], fromIndex: Int)
  case Remove(range: Range<Int>)
  case Reset(array: [ElementType])
  case Batch([ObservableArrayOperation<ElementType>])
}

/// A array event change set represents a description of the change that 
/// the array event operation does to a array in a way suited for application
/// to the UIKit collection views like UITableView or UICollectionView
public enum ObservableArrayEventChangeSet {
  case Inserts(Set<Int>)
  case Updates(Set<Int>)
  case Deletes(Set<Int>)
}

public func ==(lhs: ObservableArrayEventChangeSet, rhs: ObservableArrayEventChangeSet) -> Bool {
  switch (lhs, rhs) {
  case (.Inserts(let l), .Inserts(let r)):
    return l == r
  case (.Updates(let l), .Updates(let r)):
    return l == r
  case (.Deletes(let l), .Deletes(let r)):
    return l == r
  default:
    return false
  }
}

public extension ObservableArrayOperation {
  
  /// Maps elements encapsulated in the operation.
  public func map<X>(transform: ElementType -> X) -> ObservableArrayOperation<X> {
    switch self {
    case .Reset(let array):
      return .Reset(array: array.map(transform))
    case .Insert(let elements, let fromIndex):
      return .Insert(elements: elements.map(transform), fromIndex: fromIndex)
    case .Update(let elements, let fromIndex):
      return .Update(elements: elements.map(transform), fromIndex: fromIndex)
    case .Remove(let range):
      return .Remove(range: range)
    case .Batch(let operations):
      return .Batch(operations.map{ $0.map(transform) })
    }
  }
  
  public func filter(includeElement: ElementType -> Bool, inout pointers: [Int]) -> ObservableArrayOperation<ElementType>? {
    
    switch self {
    case .Insert(let elements, let fromIndex):
      
      for (index, element) in pointers.enumerate() {
        if element >= fromIndex {
          pointers[index] = element + elements.count
        }
      }
      
      var insertedIndices: [Int] = []
      var insertedElements: [ElementType] = []
      
      for (index, element) in elements.enumerate() {
        if includeElement(element) {
          insertedIndices.append(fromIndex + index)
          insertedElements.append(element)
        }
      }
      
      if insertedIndices.count > 0 {
        let insertionPoint = startingIndexForIndex(fromIndex, forPointers: pointers)
        pointers.insertContentsOf(insertedIndices, at: insertionPoint)
        return .Insert(elements: insertedElements, fromIndex: insertionPoint)
      }
      
    case .Update(let elements, let fromIndex):
      
      var operations: [ObservableArrayOperation<ElementType>] = []
      
      for (index, element) in elements.enumerate() {
        let realIndex = fromIndex + index
        
        // if element on this index is currently included in filtered array
        if let location = pointers.indexOf(realIndex) {
          if includeElement(element) {
            // update
            operations.append(.Update(elements: [element], fromIndex: location))
          } else {
            // remove
            pointers.removeAtIndex(location)
            operations.append(.Remove(range: location..<location+1))
          }
        } else { // element in this index is currently NOT included
          if includeElement(element) {
            // insert
            let insertionPoint = startingIndexForIndex(realIndex, forPointers: pointers)
            pointers.insert(realIndex, atIndex: insertionPoint)
            operations.append(.Insert(elements: [element], fromIndex: insertionPoint))
          } else {
            // not contained, not inserted - do nothing
          }
        }
      }
      
      if operations.count == 1 {
        return operations.first!
      } else if operations.count > 1 {
        return .Batch(operations)
      }
      
    case .Remove(let range):
      
      var startIndex = -1
      var endIndex = -1
      
      for (index, element) in pointers.enumerate() {
        if element >= range.startIndex {
          if element < range.endIndex {
            if startIndex < 0 {
              startIndex = index
              endIndex = index + 1
            } else {
              endIndex = index + 1
            }
          }
          
          pointers[index] = element - range.count
        }
      }
      
      if startIndex >= 0 {
        let removedRange = Range(start: startIndex, end: endIndex)
        pointers.removeRange(removedRange)
        return .Remove(range: removedRange)
      }
      
    case .Reset(let array):
      pointers = pointersFromSequence(array, includeElement: includeElement)
      return .Reset(array: array.filter(includeElement))
      
    case .Batch(let operations):
      
      var filteredOperations: [ObservableArrayOperation<ElementType>] = []
      
      for operation in operations {
        if let filtered = operation.filter(includeElement, pointers: &pointers) {
          filteredOperations.append(filtered)
        }
      }
      
      if filteredOperations.count == 1 {
        return filteredOperations.first!
      } else if filteredOperations.count > 0 {
        return .Batch(filteredOperations)
      }
    }
    
    return nil
  }
  
  /// Generates the `ObservableArrayEventChangeSet` representation of the operation.
  public func changeSet() -> ObservableArrayEventChangeSet {
    switch self {
    case .Insert(let elements, let fromIndex):
      return .Inserts(Set(fromIndex..<fromIndex+elements.count))
    case .Update(let elements, let fromIndex):
      return .Updates(Set(fromIndex..<fromIndex+elements.count))
    case .Remove(let range):
      return .Deletes(Set(range))
    case .Reset:
      fallthrough
    case .Batch:
      fatalError("Dear Sir/Madam, I cannot generate changeset for \(self) operation.")
    }
  }
}

internal func pointersFromSequence<S: SequenceType>(sequence: S, includeElement: S.Generator.Element -> Bool) -> [Int] {
  var pointers: [Int] = []
  for (index, element) in sequence.enumerate() {
    if includeElement(element) {
      pointers.append(index)
    }
  }
  return pointers
}

internal func startingIndexForIndex(x: Int, forPointers pointers: [Int]) -> Int {
  var idx: Int = -1
  for (index, element) in pointers.enumerate() {
    if element < x {
      idx = index
    } else {
      break
    }
  }
  return idx + 1
}

public func offsetOfIndex<T>(index: Int, byApplyingOperations operations: ArraySlice<ObservableArrayOperation<T>>) -> Int {
  var offset = 0
  
  for operation in operations {
    switch operation {
    case .Insert(let elements, let fromIndex):
      let endIndex = fromIndex + elements.count
      if fromIndex < index {
        let diff = endIndex - fromIndex
        offset = offset - diff
      }
    case .Remove(let range):
      if range.startIndex <= index {
        let diff = range.endIndex - range.startIndex
        offset = offset + diff
      }
    default:
      break
    }
  }
  
  return offset
}

public func deletesOffsetOfIndex<T>(index: Int, byApplyingOperations operations: ArraySlice<ObservableArrayOperation<T>>) -> Int {
  var offset = 0
  
  for operation in operations {
    switch operation {
    case .Remove(let range):
      if range.startIndex <= index {
        let diff = range.endIndex - range.startIndex
        offset = offset + diff
      }
    default:
      break
    }
  }
  
  return offset
}

public func operationOffset<T>(operation: ObservableArrayOperation<T>) -> Int {
  switch operation {
  case .Insert(let elements, _):
    return elements.count
  case .Remove(let range):
    return -range.count
  default:
    return 0
  }
}

public func operationStartIndex<T>(operation: ObservableArrayOperation<T>) -> Int {
  switch operation {
  case .Insert(_, let fromIndex):
    return fromIndex
  case .Remove(let range):
    return range.startIndex
  default:
    return 0
  }
}

/// This function is used by UICollectionView and UITableView bindings.
/// Batch operations are expected to be sequentially applied to the array/array, which is not what those views do.
/// The function converts operations into a "diff" discribing elements at what indices changed and in what way.
///
/// Complexity: O(n^2) where n is a number of operations applied to the array.
///
/// For example, when following (valid) input is given:
///   [.Insert([A], 0), .Insert([B], 0)]
/// function should produce following output:
///   [.Inserts([0, 1])]
///
/// Or:
///   [.Insert([B], 0), .Remove(1)] -> [.Inserts([0]), .Deletes([0])]
///   [.Insert([A], 0), .Insert([B], 0), .Remove(1)] -> [.Inserts([0])]
///   [.Insert([A], 0), .Remove(0)] -> []
///   [.Insert([A, B], 0), .Insert([C, D], 1)] -> [.Inserts([0, 1, 2, 3])]
///
public func changeSetsFromBatchOperations<T>(operations: [ObservableArrayOperation<T>]) -> [ObservableArrayEventChangeSet] {
  
  func shiftSet(set: Set<Int>, from: Int, by: Int) -> Set<Int> {
    var shiftedSet = Set<Int>()
    
    for element in set {
      if element >= from {
        shiftedSet.insert(element + by)
      } else {
        shiftedSet.insert(element)
      }
    }
    
    return shiftedSet
  }
  
  var inserts = Set<Int>()
  var updates = Set<Int>()
  var deletes = Set<Int>()
  
  for (operationIndex, operation) in operations.enumerate() {
    switch operation {
    case .Insert(let elements, let fromIndex):
      
      // All previous inserts that happened on indices equal or greater to current one should be shifted by a number of inserted element
      inserts = Set(inserts.map { $0 >= fromIndex ? $0 + elements.count : $0 })
      
      // If there was any prior deletion operation up to our insertion index, it shifts our inserts
      let correctionOffset = deletesOffsetOfIndex(fromIndex, byApplyingOperations: operations.prefixUpTo(operationIndex))
      let newInserts = Set(fromIndex + correctionOffset ..< fromIndex + correctionOffset + elements.count)
      
      // Insertions to deleted indices are actually updates
      let replaced = deletes.intersect(newInserts)
      deletes.subtractInPlace(replaced)
      updates.unionInPlace(replaced)
      
      inserts.unionInPlace(newInserts.subtract(replaced))
      
    case .Update(let elements, let fromIndex):
  
      // Updates done to the elements that were inserted in this batch must be discared
      var newUpdates = Array(Set(fromIndex..<fromIndex+elements.count).subtract(inserts))

      // Any prior insertion or deletion shifts our indices
      for operation in operations.prefixUpTo(operationIndex) {
        let offset = -operationOffset(operation)
        if offset != 0 {
          let startIndex = operationStartIndex(operation)
          newUpdates = newUpdates.map { $0 >= startIndex ? $0 + offset : $0 }
        }
      }
      
      updates.unionInPlace(newUpdates)
      
    case .Remove(let range):
      let possibleNewDeletes = Set(range)
      
      // Elements that were inserted and then removed in this batch must be discared
      let annihilated = inserts.intersect(possibleNewDeletes)
      inserts.subtractInPlace(annihilated)
      
      let actualNewDeletes = possibleNewDeletes.subtract(annihilated)
      
      // Elements that were updated and then removed in this batch must be discared
      updates.subtractInPlace(actualNewDeletes)
      
      // Any prior insertion or deletion shifts our indices
      let correctionOffset = (operationIndex > 0) ? offsetOfIndex(range.startIndex, byApplyingOperations: operations.prefixUpTo(operationIndex)) : 0
      let correctedNewDeletes = actualNewDeletes.map { $0 + correctionOffset }
      
      deletes.unionInPlace(correctedNewDeletes)

      // Should this be like in updates??
      if let minIndex = possibleNewDeletes.minElement() {
        inserts = shiftSet(inserts, from: minIndex, by: -annihilated.count)
      }
      
    case .Reset:
      fatalError("Dear Sir/Madam, the .Reset operation within the .Batch is not supported at the moment!")
    case .Batch:
      fatalError("Dear Sir/Madam, nesting the .Batch operations is not supported at the moment!")
    }
  }
  
  var changeSets: [ObservableArrayEventChangeSet] = []
  
  if inserts.count > 0 {
    changeSets.append(.Inserts(inserts))
  }
  
  if updates.count > 0 {
    changeSets.append(.Updates(updates))
  }
  
  if deletes.count > 0 {
    changeSets.append(.Deletes(deletes))
  }
  
  return changeSets
}
